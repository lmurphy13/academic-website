<!DOCTYPE html>
<html>
	<head>	
		<title>Daily Log</title>
		<link rel="stylesheet" type="text/css" href="style.css" />
	</head>

	<body>
	<h1 class="title-block">Daily Research Log</h1>

	<table class="content" style="width: 60%; margin-left: auto; margin-right: auto;" border="1px solid black">
		<tr>
			<td>
				<p>
					Sunday, November 14, 2021: Worked on commenting out the now-unnecessary push/pop code and making sure the original <code>ldr</code> and <code>str</code> opcodes are still present within the frame prologue and epilogue. I am still unable to get proper returning without including <code>push/pop pc, lr</code>. More information will be needed to get the MIPS-style frame behavior. There is still issue with the <code>new</code> Xinu system call.
				</p>
			</td>
		</tr>

		<tr>
			<td>
				<p>
					Thursday, November 11, 2021: Met with Dr. Brylow and discussed the issue with push/pop registers. We learned that each callee-save register is getting moved onto the stack in MIPS. The redundant moves are eliminated by the compiler optimization, so the essential live-in registers remain. Additionally, it would be difficult to implement "dynamic" push/pop opcodes in frame prologues and epilogues because there is no IR node that represents these opcodes. For now, we will stick with the original design decision of just manually moving registers on and off the stack.
				</p>

				<p>
					We discussed some administrative paperwork and I emailed Jackie about scheduling a section of COSC 6999: Master's Thesis with Dr. Brylow as the instructor.
				</p>
			</td>
		</tr>
		
		<tr>
			<td>
				<p>
					Sunday, November 7, 2021: Progress is moving slowly now. I have been busy with work/unmotivated, so I have not made much substantive progress. However, I have identified some issues:
				</p>
				<ul>
					<li>
						Both the MIPS and ARM compilers treat functions without any "action" as having a framesize of 0. For example:
					
						<br><br>	
						<code>
							public SomeClass init() {
								return this;
							}							
						</code>
						<br><br><br>
						Since MiniJava doesn't really have constructors, this is how we can "get" an object. This code snippet is compiled with a framesize of zero. I suspect that since no variables are declared within the body of the function, no offsets from the stackframe are needed. This is a problem, though, because I need to "get" an object before I can call one of its methods. I still think this has something to do with argument passing. Another issue with this frame setup is that no <code>push/pop</code> opcodes are generated. There must be some limit of the grammar that does not allow for "empty" functions.
					</li>
					<li>
						Return values are being stomped on by function epilogues. A return value from a function gets moved into <code>r0</code>, but then gets overridden by the function epilogue using <code>r0</code> to manipulate the stack pointer. Example:
						<br><br>
						<pre>
						<code>
L6:
        ldr     r0,     =L9
        bl      _print
        // Call sink
        bl      _println
        // Call sink
        // THIS ONE
        mov     r0,     #1
        b       L14
L8:
        ldr     r0,     =L5
        bl      _print
        // Call sink
        bl      _println
        // Call sink
        add     r0,     r5,     #1
        mov     r5,     r0
        b       L7
L14:
        add     r0,     fp,     Hellorun_run_framesize
        mov     r0,     r4
        mov     r7,     r6
        ldr     r6,     [fp, #-4]
        ldr     r5,     [fp, #-8]
        ldr     r4,     [fp, #-12]
        // return from Hellorun_run
        sub     sp,     fp,     #4
        pop     { fp, lr }
        bx      lr
						</code>						
						</pre>
						<br><br><br>
						Notice how the <code>mov</code> in <code>L6</code> moves a 1 into <code>r0</code>, the standard ARM return value register. Then the program branches to <code>L14</code>, where <code>r0</code> gets demolished by the setup for the return. 


						
						I do not know how to get around this, yet.
					</li>
				</ul>


			</td>
		</tr>
		
		<tr>
			<td>
				<p>
					Wednesday, November 3, 2021: Walked to Dr. Brylow's office. He was not there.
				</p>
			</td>
		</tr>
		
		<tr>
			<td>
				<p>
					Wednesday, October 27, 2021: Met with Dr. Brylow today. We had a good discussion and made some design decisions about how to implement Arm frame prologues and epilogue, using push and pop and inline offsets in an effort to eliminate some of the unreadable Mips-era code generation. 
				</p>
			</td>
		</tr>
		
		
		<tr>
			<td>
				<p>
					Saturday, October 23, 2021: It has become apparent that there are several issues with ARM stack frame generation. The previous MIPS backend is unable to adequately be converted to return from ARM functions as of
					right now. I will need to discuss with Dr. Brylow more about:
					<ul>
						<li>Creating and destroying stack frames</li>
						<li>Returning from a function</li>
						<li>Returning from a callee function to a caller function</li>
						<li>Whether we need to start using push and pop calls</li>
					</ul>

					I disassembled some object code generated by the Xinu ARM cross-compiler and saw that it uses push and pop calls. Maybe it would be easier to go that route rather than manually manipulating the stack pointer. 
					This may become a large roadblock. The MIPS code generator is using a jump table to move around function calls. Maybe we can reuse that in ARM.
				</p>
			</td>
		</tr>
		
		
		<tr>
			<td>
				<p>
					Wednesday, October 20, 2021: Met with Dr. Brylow today. Showed him my progress on the code and my thesis. He gave me the <code>minijava.c</code> file that implements some of the system calls used by the MiniJava compiler. He also showed me how to compile the output of the MiniJava compiler into Xinu. 
				</p>

				<p>
				There were initially some issues with getting the code to compile, but we can now compile very basic programs. Concurrency features are not yet supported. A bug was discovered with the register allocator. Certain registers were being used that were being overridden by procedure calls. This was resolved. An outstanding issue remains when trying to return from a function call nested within another function call. 
				</p>

				<p>
					<strong>TO DO:</strong> Keep working on writing. Get all basic functionality working before implementing other "nice-to-have" features, like concurrency. Contact Praveen regarding graduation.
				</p>
			</td>
		</tr>

		<tr>
			<td>
				<p>
					Sunday, October 17, 2021: <code>Arm/Codegen.java</code> is complete, but generates semantically incorrect ARM. One large issue of note is that any generated macros contain a <code>.</code> and are causing issues when assembling. I am trying to track down where a period is getting added to the frame's name, but I am not having much luck as of yet. Once that is solved, there are two more large problems that need to get fixed:


					<ol>
						<li>Function prologue/epilogue</li>
						<li><code>str</code> syntax
					</ol>
				</p>

				<p>
					Currently, the ARM code generator inherits MIPS-style stack frame allocation, which involves a set of moves and stores to get caller-save registers figured out. This will need to get changed so that ARM push/pop opcodes are called instead. Also, instead of executing a <code>bx 000000de> statement at the end of a function, the ARM code generator uses the MIPS method of subtracting from the stack pointer to move into the scope of the caller function. I am unsure if this works in ARM. I may need to find a way to keep track of the caller and branch to it at the end of the callee.


				</p>

				<p>
					The <code>str</code> instruction is currently being generated with its parameters out of order. This should be a simple fix. 
				</p>

				<p>
					<strong>UPDATE:</strong> Technically everything assembles but is missing the Xinu calls. Need to ask Dr. Brylow how to hook in the .S into Xinu
				</p>
			</td>
		</tr>
		
		<tr>
			<td>
				<p>
					Saturday, October 16, 2021: Nearly done with <code>Arm/Codegen.java</code> and will begin preliminary testing ASAP. Also, started thinking about organization for Chapters 2 and 3, Background and Related Work chapters. 
				</p>
			</td>
		</tr>
		
		<tr>
			<td>
				<p>
					Friday, October 15, 2021: Continued work on <code>Arm/Codegen.java</code>. Had some realizations about the ARM architecture vs. MIPS, so I needed to refactor a bit of the code. Some legacy things like <code>Frame.					ZERO</code> were retained in order to make code emission easier. In the <code>Arm</code> package, <code>Frame.ZERO</co000000s been itialized as <code>#0</code>, since MIPS uses a zero register to hold the same value. The easiest solution, to me, was to just set that "register" to the immediate zero value.

				</p>
			</td>
		</tr>
		
		<tr>
			<td>
				<p>
					Wednesday, October 13, 2021: Had weekly meeting with Dr. Brylow. Had a good discussion and several questions answered. Contacted Alex G. to get a copy of the Research Xinu source.
				</p>
				<p>
					<strong>Code Progress:</strong>
					<br>
					Finished initial modifications of <code>Arm/ArmFrame.java, Arm/InReg.java, Arm/InFrame.java</code>. Started working on <code>Arm/Codegen.java</code>. Worked on converting store convention from Mips to Arm.
				</p>
				<p>
					<strong>Writing Progress:</strong>
					<br>
					More messing around with formatting. Got the go-ahead from Dr. Brylow to start writing some sections. Will start on Background chapter this week. 
					It is still unclear what the overall goal is of the thesis, but that's okay for now.
				</p>
			</td>
		</tr>
		
		<tr>
			<td>
				<p>
					Saturday, October 9, 2021: Bookmarked important sections of <i>Dragon Book</i> Chapter 8 and Appel Chapter 8. Started considering how to create Arm Basic Blocks. Wrote a cheatsheet on Arm 32 bit registers. 
				</p>
			</td>
		</tr>

		<tr>
			<td>
				<p>
					Friday, October 8, 2021: Read the first half of <i>Dragon Book</i> Chapter 8. Looked more at existing compiler codebase. Began thinking about thesis chapters.
				</p>
			</td>
		</tr>
			
		<tr>
			<td>
				<p>
					Thursday, October 7, 2021: Dr. Brylow gave me access to the ConcurrentMiniJava compiler GitHub repository. I have forked that repository into my own GitHub account. After doing so, I cloned the repo to my Morbius
					home directory. I began laying out the <code>Arm</code> package. I have also written a bash script to build the compiler for me. I will need to brush up on my ARM assembly.
					<br><br>
					<strong>TODO: </strong>Ask Dr. Brylow for the latest stable version of multicore Embedded Xinu.
				</p>
			</td>
		</tr>
		
		<tr>
			<td>
			<p>
				Tuesday, October 5, 2021: <i>Compilers: Principles, Techniques, & Tools</i> arrived in the mail. Began skimming the first few chapters.
					Added to <a href="sources.html">list of sources</a>.
				</p>
			</td>
		</tr>
		
		<tr>
			<td>
				<p>
					Friday, October 1, 2021: Read Mallen & Brylow compiler paper. Added to <a href="sources.html">list of sources</a>.
				</p>
			</td>
		</tr>
		
		<tr>
			<td>	
				<p>
					Wednesday, September 29, 2021: Met with Dr. Brylow to go over expectations and to discuss a topic.
					A topic was selected: work on porting the MiniJava compiler to ARM and bring in cryptography and concurrency libraries.
					<br><br>
					<strong>TODO: </strong>Read Mallen & Brylow Compiler paper, submit thesis paperwork. 
				</p>
			</td>
		</tr>
	</table>

	<p>
		Entries are ordered from most recent to least recent.

	</p>

	</body>

	<footer style="text-align: center">
		<hr style="width: 75%">
		Go <a href="index.html">back</a>.
	</footer>
</html>
